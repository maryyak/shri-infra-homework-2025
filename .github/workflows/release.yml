name: Release

on:
  workflow_dispatch:

jobs:
  # Параллельные проверки
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test

  # Основная задача релиза
  release:
    runs-on: ubuntu-latest
    needs: [lint, test]  # Зависимость от успешного завершения lint и test
    permissions:
      contents: write
      issues: write
    env:
      REGISTRY: ${{ secrets.REGISTRY_ID }}
      VERSION: ${{ github.run_number }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      # Создание релизной ветки
      - name: Create release branch
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git checkout -b releases/$VERSION
          git push origin releases/$VERSION

      # Сборка и загрузка Docker-образа
      - name: Build and push Docker image
        env:
          YC_SA_KEY: ${{ secrets.YC_SA_KEY }}
        run: |
          echo "$YC_SA_KEY" | docker login \
            --username json_key \
            --password-stdin \
            cr.yandex
          
          # Сборка образа
          docker build -t $REGISTRY/app:$VERSION .
          docker tag $REGISTRY/app:$VERSION $REGISTRY/app:${VERSION}_latest
          
          # Загрузка образов с двумя тегами
          docker push $REGISTRY/app:$VERSION
          docker push $REGISTRY/app:${VERSION}_latest

      # Создание тега
      - name: Create tag
        run: |
          git tag v$VERSION
          git push origin v$VERSION

      # Создание Issue и обновление CHANGELOG
      - name: Create release artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            try {
              // Получаем все теги
              const { data: tags } = await github.rest.repos.listTags({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              console.log(`Found ${tags.length} tags`);

              // Находим последний релизный тег (начинается с 'v' и не содержит 'fix')
              const releaseTags = tags.filter(tag => 
                tag.name.startsWith('v') && 
                !tag.name.toLowerCase().includes('fix') &&
                tag.name !== `v${process.env.VERSION}` // Исключаем текущий тег
              );

              console.log(`Found ${releaseTags.length} release tags`);

              // Сортируем по номеру версии (по убыванию)
              releaseTags.sort((a, b) => {
                const numA = parseInt(a.name.substring(1));
                const numB = parseInt(b.name.substring(1));
                return numB - numA;
              });

              let lastReleaseTag = releaseTags.length > 0 ? releaseTags[0].name : null;
              let commitMessages = [];

              console.log(`Last release tag: ${lastReleaseTag}`);

              if (lastReleaseTag) {
                // Получаем коммиты между последним релизом и текущим main
                try {
                  const compare = await github.rest.repos.compareCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    base: lastReleaseTag,
                    head: 'main'
                  });
            
                  commitMessages = compare.data.commits
                    .map(c => c.commit.message.split('\n')[0])
                    .filter(msg => !msg.toLowerCase().includes("merge"))
                    .slice(0, 20); // Ограничиваем количество коммитов
            
                  console.log(`Found ${commitMessages.length} commits since last release`);
                } catch (error) {
                  console.log(`Error comparing commits: ${error.message}`);
                  commitMessages = [`Unable to fetch commits since ${lastReleaseTag}`];
                }
              } else {
                // Для первого релиза берем последние 10 коммитов
                try {
                  const { data: commits } = await github.rest.repos.listCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    sha: 'main',
                    per_page: 10
                  });
            
                  commitMessages = commits
                    .map(c => c.commit.message.split('\n')[0])
                    .filter(msg => !msg.toLowerCase().includes("merge"));
            
                  console.log(`Found ${commitMessages.length} commits for first release`);
                } catch (error) {
                  console.log(`Error fetching commits: ${error.message}`);
                  commitMessages = ['Initial release'];
                }
              }

              // Создаем Issue
              const issueBody = `**Версия:** ${process.env.VERSION}
  
              **Автор релиза:** ${context.actor}
              
              **Дата:** ${new Date().toISOString()}
              
              **Коммиты с последнего релиза:**
              ${commitMessages.map(msg => `- ${msg}`).join('\n')}
              
              **Docker-образ:**
              \`cr.yandex/${process.env.REGISTRY_ID}/app:${process.env.VERSION}\`
              
              **Ссылка на образ в Yandex Container Registry:**
              https://console.yandex.ru/folders/${process.env.REGISTRY_ID}/container-registry/registries
              `;
              
              const issue = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `Release ${process.env.VERSION}`,
            body: issueBody,
            labels: ['release']
            });
              
              console.log(`Created issue #${issue.data.number}`);
              
              // Обновляем CHANGELOG.md
              let changelog = '';
              if (fs.existsSync('CHANGELOG.md')) {
              changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
              } else {
              changelog = '# Changelog\n\nAll notable changes to this project will be documented in this file.\n\n';
              }
              
              const date = new Date().toISOString().split('T')[0];
              const newEntry = `## v${process.env.VERSION} - ${date}\n\n${commitMessages.map(msg => `- ${msg}`).join('\n')}\n\n`;
              
              const updatedChangelog = changelog.replace(
              /^(# Changelog\n\n.*?\n\n)/,
              `$1${newEntry}`
              );
              
              fs.writeFileSync('CHANGELOG.md', updatedChangelog);
              console.log('Updated CHANGELOG.md');
              
              // Коммитим изменения в релизную ветку
              execSync('git add CHANGELOG.md');
              execSync(`git commit -m "Update CHANGELOG for v${process.env.VERSION}"`);
              execSync(`git push origin releases/${process.env.VERSION}`);
              
              console.log('Pushed CHANGELOG changes to release branch');
            
            } catch (error) {
              console.error('Error creating release artifacts:', error);
            core.setFailed(`Release artifacts creation failed: ${error.message}`);
              
              // Создаем минимальный релиз в случае ошибки
              const fs = require('fs');
              const { execSync } = require('child_process');
              
              try {
              const minimalChangelog = `## v${process.env.VERSION} - ${new Date().toISOString().split('T')[0]}\n\nRelease v${process.env.VERSION}\n\n`;
              
              let currentChangelog = '';
              if (fs.existsSync('CHANGELOG.md')) {
              currentChangelog = fs.readFileSync('CHANGELOG.md', 'utf8');
              fs.writeFileSync('CHANGELOG.md', currentChangelog.replace(
              /^(# Changelog\n\n.*?\n\n)/,
              `$1${minimalChangelog}`
              ));
              } else {
              fs.writeFileSync('CHANGELOG.md', `# Changelog\n\nAll notable changes to this project will be documented in this file.\n\n${minimalChangelog}`);
              }
              
              execSync('git add CHANGELOG.md');
              execSync(`git commit -m "Add minimal CHANGELOG for v${process.env.VERSION}"`);
              execSync(`git push origin releases/${process.env.VERSION}`);
              
              console.log('Created minimal release as fallback');
            } catch (fallbackError) {
              console.error('Fallback release creation also failed:', fallbackError);
            }
            }
