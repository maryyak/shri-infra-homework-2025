name: Release
on:
  workflow_dispatch:

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm ci
      - run: npm run lint

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm ci
      - run: npm run test

  release:
    runs-on: ubuntu-latest
    needs: [lint, test]
    permissions:
      contents: write
      issues: write
    env:
      REGISTRY: ${{ secrets.REGISTRY_ID }}
    outputs:
      version: ${{ steps.set-version.outputs.VERSION }}

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set version
        id: set-version
        run: echo "VERSION=${{ github.run_number }}" >> $GITHUB_OUTPUT

      - name: Create release branch
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git checkout -b releases/${{ steps.set-version.outputs.VERSION }}
          git push origin releases/${{ steps.set-version.outputs.VERSION }}

      - name: Build and push Docker image
        env:
          YC_SA_KEY: ${{ secrets.YC_SA_KEY }}
        run: |
          echo "$YC_SA_KEY" | docker login \
            --username json_key \
            --password-stdin cr.yandex
          docker build -t $REGISTRY/app:${{ steps.set-version.outputs.VERSION }} .
          docker tag $REGISTRY/app:${{ steps.set-version.outputs.VERSION }} $REGISTRY/app:${{ steps.set-version.outputs.VERSION }}_latest
          docker push $REGISTRY/app:${{ steps.set-version.outputs.VERSION }}
          docker push $REGISTRY/app:${{ steps.set-version.outputs.VERSION }}_latest

      - name: Create Git tag
        run: |
          git tag v${{ steps.set-version.outputs.VERSION }}
          git push origin v${{ steps.set-version.outputs.VERSION }}

      - name: Create issue and update changelog
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            const version = process.env.VERSION;
  
              // 1) Получаем все теги
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
              
              // 2) Извлекаем их имена, отфильтровываем релизные и сортируем по убыванию
              const releaseTagNames = tags
              .map(t => t.name)
              .filter(name => name.startsWith('v') && !name.includes('fix'))
              .sort((a, b) => parseInt(b.slice(1), 10) - parseInt(a.slice(1), 10));
              
              // 3) Ищем предыдущий релизный тег (отличный от текущего)
              const previousTag = releaseTagNames.find(name => name !== `v${version}`);
              console.log('Previous release tag:', previousTag || '«никогда не выпускали»');
              
              // 4) Сравниваем коммиты между предыдущим тегом и текущим коммитом
              let compare;
              if (previousTag) {
              compare = await github.rest.repos.compareCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            base: previousTag,
            head: context.sha
            });
            } else {
              // Если это первый выпуск — берём только текущий коммит
              compare = await github.rest.repos.compareCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            base: `${context.sha}^`,
            head: context.sha
            });
            }
  
            // 5) Составляем список коротких сообщений коммитов
            const commitMessages = compare.data.commits
            .map(c => c.commit.message.split('\n')[0])
            .filter(msg => !msg.startsWith('Merge'));
            
            console.log(`Found ${commitMessages.length} new commits:`);
            commitMessages.forEach(m => console.log('  •', m));
            
            const changelogEntry = `# v${version}\n\n` +
              commitMessages.map(msg => `- ${msg}`).join('\n') + '\n\n';

            const changelogPath = 'CHANGELOG.md';
            let previous = fs.existsSync(changelogPath) ? fs.readFileSync(changelogPath, 'utf8') : '';
            fs.writeFileSync(changelogPath, changelogEntry + previous);

            execSync('git config user.name "GitHub Actions"');
            execSync('git config user.email "actions@github.com"');
            execSync('git add CHANGELOG.md');
            execSync(`git commit -m "Update CHANGELOG for v${version}"`);
            execSync(`git push origin releases/${version}`);

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Release ${version}`,
              body:
                `**Version:** ${version}\n\n` +
                `**Author:** ${author}\n\n` +
                `**Date:** ${new Date().toISOString()}\n\n` +
                `**Commits since last release:**\n${commitMessages.map(m => `- ${m}`).join('\n')}\n\n` +
                `**Docker image:** \`${registry}/app:${version}\``
            });
